<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>pyqofta.scattering API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pyqofta.scattering</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import numpy as np
import numpy.typing as npt
from pyqofta.molecules import Molecule
from pyqofta.trajectories import Ensemble, Trajectory, TrajectorySH

&#39;&#39;&#39;
Author: Kyle Acheson

A module for calculating scattering observables for individual molecules, trajectories and ensembles of trajectories.
So far limited to rotationally averaged elastic scattering within the IAM for Surface Hopping trajectories.
Will soon include elastic scattering for Gaussian wavepacket based methods within the BAT approximation for the
calculation of off-diagonal terms between different trajectories. An interface to Ab-initio scattering code may
one day be implemented.
&#39;&#39;&#39;

__all__ = [
    &#39;IAM_ensemble_scattering&#39;,
    &#39;IAM_trajectory_scattering&#39;,
    &#39;IAM_molecular_scattering&#39;,
    &#39;IAM_form_factors&#39;
]

class FormFactorParameterisationError(ValueError):
    def __init__(self, msg=&#39;Form factor for the requested atom needs to be paramteterised&#39;, *args, **kwargs):
        super().__init__(msg, *args, **kwargs)

class MoleculeTypeError(TypeError):
    def __init__(self, msg=&#39;Requires a Molecule object&#39;, *args, **kwargs):
        super().__init__(msg, *args, **kwargs)

class TrajectoryTypeError(TypeError):
    def __init__(self, msg=&#39;Requires a Trajectory object&#39;, *args, **kwargs):
        super().__init__(msg, *args, **kwargs)

class EnsembleTypeError(TypeError):
    def __init__(self, msg=&#39;Requires a Ensemble object&#39;, *args, **kwargs):
        super().__init__(msg, *args, **kwargs)



IAM_factors_dict = {&#39;H&#39;: {&#39;a&#39;: [0.493002, 0.322912, 0.140191, 0.040810], &#39;b&#39;: [10.5109, 26.1257, 3.14236, 57.7997], &#39;c&#39;: 0.003038},
                    &#39;C&#39;: {&#39;a&#39;: [2.26069, 1.56165, 1.05075, 0.839259], &#39;b&#39;: [22.6907, 0.656665, 9.75618, 55.5949], &#39;c&#39;: 0.286977},
                    &#39;S&#39;: {&#39;a&#39;: [6.90530, 5.20340, 1.43790, 1.58630], &#39;b&#39;: [1.46790, 22.2151, 0.253600, 56.1720], &#39;c&#39;: 0.866900}
                    }


def IAM_ensemble_scattering(ensemble, qvec: npt.NDArray, fq: npt.NDArray, FF: npt.NDArray, ELEC=False) -&gt; list:
    if not isinstance(ensemble, Ensemble):
        raise EnsembleTypeError(&#39;To calculate scattering over an ensemble an Ensemble object is required&#39;)
    Iens = ensemble.broadcast(IAM_trajectory_scattering, ensemble, qvec, fq, FF, ELEC)
    return list(Iens)

def IAM_trajectory_scattering(trajectory, qvec, fq, FF, ELEC=False):
    if not isinstance(trajectory, Trajectory):
        raise TrajectoryTypeError(&#39;To calculate the scattering over time a Trajectory object is required.&#39;)
    Itrj = trajectory.broadcast(IAM_molecular_scattering, trajectory, qvec, fq, FF, ELEC)
    return np.array(list(Itrj))


def IAM_molecular_scattering(molecule, qvec, fq, FF, ELEC=False):
    Nq = len(qvec)
    Imol = np.zeros(Nq)
    Iat = sum(fq**2)
    for i in range(molecule.natoms):
        for j in range(i+1, molecule.natoms):
            qr_ij = qvec * np.linalg.norm(molecule.coordinates[i, :] - molecule.coordinates[j, :])
            sin_qr_ij = np.sinc(qr_ij)
            Imol += 2 * FF[i, j, :] * sin_qr_ij
    if ELEC:
        Itot = (qvec * Imol)/Iat # sM (modified scattering used in ued community)
        return Itot
    else:
        Itot = Imol + Iat
        print(Itot[100], molecule.coordinates[0, 1])
        return Itot # standard xrs



def IAM_form_factors(molecule, qvec: npt.NDArray, ELEC=False) -&gt; tuple[npt.NDArray, npt.NDArray]:
    &#34;&#34;&#34;
    Gets the IAM form factors for a given molecule (either x-ray or electron), also calculates the form factor
    product that appear as diagonal terms - saves calculation of the diagonal terms at every time step.
    :param molecule: a molecular structure
    :type molecule: Molecule
    :param qvec: momentum transfer vector in inverse angstrom
    :type qvec: numpy.ndarray
    :param ELEC: flag to request electron scattering factors instead of x-ray (default=False)
    :type ELEC: Bool
    :return: form factor products (sum**2 amounts diagonal term in IAM equation) and form factors
    :rtype: numpy.ndarray
    &#34;&#34;&#34;
    Nq = len(qvec)
    if not isinstance(molecule, Molecule):
        raise MoleculeTypeError(&#39;IAM form factor computation requires a Molecule object&#39;)
    if ELEC:
        fq = els(molecule.atom_labels, qvec)
    else:
        fq = xrs(molecule.atom_labels, qvec)

    FF = np.zeros((molecule.natoms, molecule.natoms, Nq))
    for i in range(molecule.natoms):
        for j in range(molecule.natoms):
            FF[i, j, :] = fq[i, :] * fq[j, :]
    return FF, fq



def xrs(atoms, qAng):
    &#34;&#34;&#34;
    Returns the x-ray scattering form factor for a given series of atoms.
    :param atoms: atmoic labels
    :type atoms: list
    :param qAng: momentum transfer vector
    :type qAng: numpy.ndarray
    :return: x-ray form factor
    :rtype: numpy.ndarray
    &#34;&#34;&#34;
    Nat = len(atoms)
    Nq = len(qAng)
    fq = np.zeros((Nat, Nq))
    for i, atom in enumerate(atoms):
        try:
            tmp = np.zeros(Nq)
            for j in range(4):
                tmp = tmp + IAM_factors_dict[atom][&#39;a&#39;][j] * np.exp(-IAM_factors_dict[atom][&#39;b&#39;][j] * (qAng / (4 * np.pi)) ** 2)
            fq[i, :] = IAM_factors_dict[atom][&#39;c&#39;] + tmp #TODO: MUST BE A WAY TO IMPROVE THIS
        # [(sum([IAM_factors_dict[atom][&#39;a&#39;][j] * np.exp(-IAM_factors_dict[atom][&#39;b&#39;][j] * (qAng / 4 * np.pi) ** 2) for j in range(4)]) + IAM_form_factors[atom][&#39;c&#39;]) for atom in atoms]
        except KeyError:
            raise FormFactorParameterisationError(f&#39;Atom {atom} not parameterised - edit IAM_factors_dict dict using ITC data&#39;)
    return fq


def els(atoms, qAng):
    &#34;&#34;&#34;
    Returns the electron scattering (Mott-Bethe) form factor for a given series of atoms.
    :param atoms: atmoic labels
    :type atoms: list
    :param qAng: momentum transfer vector
    :type qAng: numpy.ndarray
    :return: Mott-Bethe form factor
    :rtype: numpy.ndarray
    &#34;&#34;&#34;
    Nat = len(atoms)
    Nq = len(qAng)
    fq = np.zeros((Nat, Nq))
    for i, atom in enumerate(atoms):
        try:
            tmp = np.zeros(Nq)
            for j in range(4):
                tmp = tmp + IAM_factors_dict[atom][&#39;a&#39;][j] * np.exp(-IAM_factors_dict[atom][&#39;b&#39;][j] * (qAng / (4 * np.pi)) ** 2)
            fq[i, :] = (atom - (IAM_factors_dict[atom][&#39;c&#39;] + tmp)) / qAng ** 2
            # TODO: BUG HERE AS atom IS A LABEL - NO LONGER ATOMIC MASS - FIX
        except KeyError:
            raise FormFactorParameterisationError(f&#39;Atom {atom} not parameterised - edit IAM_factors_dict dict using ITC data&#39;)
    return fq</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="pyqofta.scattering.IAM_ensemble_scattering"><code class="name flex">
<span>def <span class="ident">IAM_ensemble_scattering</span></span>(<span>ensemble, qvec: numpy.ndarray[typing.Any, numpy.dtype[+ScalarType]], fq: numpy.ndarray[typing.Any, numpy.dtype[+ScalarType]], FF: numpy.ndarray[typing.Any, numpy.dtype[+ScalarType]], ELEC=False) ‑> list</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def IAM_ensemble_scattering(ensemble, qvec: npt.NDArray, fq: npt.NDArray, FF: npt.NDArray, ELEC=False) -&gt; list:
    if not isinstance(ensemble, Ensemble):
        raise EnsembleTypeError(&#39;To calculate scattering over an ensemble an Ensemble object is required&#39;)
    Iens = ensemble.broadcast(IAM_trajectory_scattering, ensemble, qvec, fq, FF, ELEC)
    return list(Iens)</code></pre>
</details>
</dd>
<dt id="pyqofta.scattering.IAM_form_factors"><code class="name flex">
<span>def <span class="ident">IAM_form_factors</span></span>(<span>molecule, qvec: numpy.ndarray[typing.Any, numpy.dtype[+ScalarType]], ELEC=False) ‑> tuple[numpy.ndarray[typing.Any, numpy.dtype[+ScalarType]], numpy.ndarray[typing.Any, numpy.dtype[+ScalarType]]]</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the IAM form factors for a given molecule (either x-ray or electron), also calculates the form factor
product that appear as diagonal terms - saves calculation of the diagonal terms at every time step.
:param molecule: a molecular structure
:type molecule: Molecule
:param qvec: momentum transfer vector in inverse angstrom
:type qvec: numpy.ndarray
:param ELEC: flag to request electron scattering factors instead of x-ray (default=False)
:type ELEC: Bool
:return: form factor products (sum**2 amounts diagonal term in IAM equation) and form factors
:rtype: numpy.ndarray</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def IAM_form_factors(molecule, qvec: npt.NDArray, ELEC=False) -&gt; tuple[npt.NDArray, npt.NDArray]:
    &#34;&#34;&#34;
    Gets the IAM form factors for a given molecule (either x-ray or electron), also calculates the form factor
    product that appear as diagonal terms - saves calculation of the diagonal terms at every time step.
    :param molecule: a molecular structure
    :type molecule: Molecule
    :param qvec: momentum transfer vector in inverse angstrom
    :type qvec: numpy.ndarray
    :param ELEC: flag to request electron scattering factors instead of x-ray (default=False)
    :type ELEC: Bool
    :return: form factor products (sum**2 amounts diagonal term in IAM equation) and form factors
    :rtype: numpy.ndarray
    &#34;&#34;&#34;
    Nq = len(qvec)
    if not isinstance(molecule, Molecule):
        raise MoleculeTypeError(&#39;IAM form factor computation requires a Molecule object&#39;)
    if ELEC:
        fq = els(molecule.atom_labels, qvec)
    else:
        fq = xrs(molecule.atom_labels, qvec)

    FF = np.zeros((molecule.natoms, molecule.natoms, Nq))
    for i in range(molecule.natoms):
        for j in range(molecule.natoms):
            FF[i, j, :] = fq[i, :] * fq[j, :]
    return FF, fq</code></pre>
</details>
</dd>
<dt id="pyqofta.scattering.IAM_molecular_scattering"><code class="name flex">
<span>def <span class="ident">IAM_molecular_scattering</span></span>(<span>molecule, qvec, fq, FF, ELEC=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def IAM_molecular_scattering(molecule, qvec, fq, FF, ELEC=False):
    Nq = len(qvec)
    Imol = np.zeros(Nq)
    Iat = sum(fq**2)
    for i in range(molecule.natoms):
        for j in range(i+1, molecule.natoms):
            qr_ij = qvec * np.linalg.norm(molecule.coordinates[i, :] - molecule.coordinates[j, :])
            sin_qr_ij = np.sinc(qr_ij)
            Imol += 2 * FF[i, j, :] * sin_qr_ij
    if ELEC:
        Itot = (qvec * Imol)/Iat # sM (modified scattering used in ued community)
        return Itot
    else:
        Itot = Imol + Iat
        print(Itot[100], molecule.coordinates[0, 1])
        return Itot # standard xrs</code></pre>
</details>
</dd>
<dt id="pyqofta.scattering.IAM_trajectory_scattering"><code class="name flex">
<span>def <span class="ident">IAM_trajectory_scattering</span></span>(<span>trajectory, qvec, fq, FF, ELEC=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def IAM_trajectory_scattering(trajectory, qvec, fq, FF, ELEC=False):
    if not isinstance(trajectory, Trajectory):
        raise TrajectoryTypeError(&#39;To calculate the scattering over time a Trajectory object is required.&#39;)
    Itrj = trajectory.broadcast(IAM_molecular_scattering, trajectory, qvec, fq, FF, ELEC)
    return np.array(list(Itrj))</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pyqofta" href="index.html">pyqofta</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="pyqofta.scattering.IAM_ensemble_scattering" href="#pyqofta.scattering.IAM_ensemble_scattering">IAM_ensemble_scattering</a></code></li>
<li><code><a title="pyqofta.scattering.IAM_form_factors" href="#pyqofta.scattering.IAM_form_factors">IAM_form_factors</a></code></li>
<li><code><a title="pyqofta.scattering.IAM_molecular_scattering" href="#pyqofta.scattering.IAM_molecular_scattering">IAM_molecular_scattering</a></code></li>
<li><code><a title="pyqofta.scattering.IAM_trajectory_scattering" href="#pyqofta.scattering.IAM_trajectory_scattering">IAM_trajectory_scattering</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>